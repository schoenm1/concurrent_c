\chapter{Umsetzung des Projektes}
\label{chapter:Umsetzung}

%============== N E W  ==== S E C T I O N  ======== 
\section{Voraussetzungen}

Da der Student kein Programmierer ist und nur schulische Kenntnisse von der Programmiersprache Java besitzt, wird dieses Projekt eine grosse Herausforderung. Deshalb soll das Grundkonzept als Stütze dienen, so dass sich der Programmierer nicht in den Details verlieren soll.

%============== N E W  ==== S E C T I O N  ======== 
\section{Libraries}
Im Unterricht des Modules \flqq Systemsoftware\frqq\ wurden verschiedene Libraries durch den Dozenten zur Verfügung gestellt.\\
Diese sollen, da sie einige Grundfunktionen wir das Error-Handling bereits beinhalten, in diesem Projekt ebenfalls genutzt werden. Die so genutzten Dateien werden nicht explizit als Quelle erwähnt. Sie besitzen jedoch im Kopf die Daten des Dozenten und sind als externe Datei erkennbar.
Als Beispiel zeigt die Abbildung \ref{fig:itskylib} die Anbindung einer externen Datei.


\lstset{language=c, mathescape=true}
\lstinputlisting[label=itskylib.c,captionpos=b, caption=itskylib.c]{dir/listings/itskylib.c}


%============== N E W  ==== S E C T I O N  ======== 
\section{Programmierumgebung}
Programmiert wird auf einem MAC OS-X 10.9 (Mavericks). Die eingesetzte Software ist das Eclipse mit dem integrierten \flqq Eclipse C/C++ Development Tools\frqq\. Eclipse ist bereits aus der Java-Programmierung im Grundstudium bekannt und eingerichtet. So musste nur noch die \flqq Eclipse C/C++ Development Tools\frqq\ installiert werden.
Der grosse Vorteil gegenüber eines Texteditors ist das Auto-Complete und die automatische Formatierung des Codes.\\
Für das Kompilieren und Ausführen des Codes wird eine Ubuntu genutzt. Dieses ist als virtuelle Maschine über Parallels installiert. Zugegriffen auf das Ubuntu wird mittels SSH von MAC OS-X. Der Grund, Ubuntu zu nutzen liegt in den anderen Bibliotheken, welche teils in MAC OS-X nicht genutzt werden können oder anders implementiert sind. Ebenfalls aufgefallen im Unterricht war, dass Ubuntu 32-bit und Ubuntu 64-bit nicht immer gleich implementiert sind.


Eckdaten Ubuntu:
\begin{itemize}
\item OS: ubuntu 12.04 LTS
\item Memory: 900 MB
\item CPU: Intel Core i7-2677M CPU @ 1.80 GHz
\item OS-Type: 64bit
\end{itemize}



%============== N E W  ==== S E C T I O N  ======== 
\section{LOG/DEBUG}
Die Implementierung des LOG soll als Erstes geschehen. So soll sichergestellt werden, dass während der Programmierung das LOG-Level geändert werden kann und allfällige Fehler schneller gesehen werden können.\\
Die Definition der LOG-Levels wird anlog zu den syslog LOG-Level erstellt:

\begin{table}[h!]
\centering
\begin{tabular}[t]{|l|l|} \hline
\centering
 \cellcolor{darkgrey} &  \cellcolor{darkgrey}  \\ 
\cellcolor{darkgrey} \multirow{-2}{3cm}{\textbf{LEVEL}} &
\cellcolor{darkgrey} \multirow{-2}{6cm}{\textbf{Bezeichnung}}  \\  \cline{1-2}
0 & EMERGENCY   \\ \cline{1-2}
1 & ALERT   \\ \cline{1-2}
2 & CRITICAL   \\ \cline{1-2}
3 & ERROR   \\ \cline{1-2}
4 & WARNING   \\ \cline{1-2}
5 & NOTICE   \\ \cline{1-2}
6 & INFORMATIONAL   \\ \cline{1-2}
7 & DEBUG   \\ \cline{1-2}
\end{tabular}
\caption{Loglevels}
\label{tab:loglevel}
\end{table}

%============== N E W  ==== S E C T I O N  ======== 
\section{Speicherverwaltung -- Buddy System}
Für die Verwaltung des Shared Memory (shm) bedarf es einer Logik, um die verschiedenen Adressen im Shared Memory richtig ansprechen zu können. Zusätzlich muss sichergestellt werden, dass kein File in das shm geschrieben wird, dass länger ist als der freie Speicherplatz, bevor das nächste File kommt.\\
Es gibt viele Dokumentierte Speicherverwaltungen. Nach längerer Recherche wurde entschieden, dass der Speicher mit dem Buddy-System verwaltet werden soll.
Die Suche im Internet nach einer vorhandenen Library für die Speicherverwaltung mit dem Buddy-System blieb leider erfolglos. Also blieb nichts anderes übrig, als das Buddy-System von grund auf selber zu gestalten und zu implementieren.\\
Dabei wurden sehr viele Fragen aufgeworfen, welche Schrittweise erarbeitet wurden

%============== N E W  ==== S U B - S E C T I O N  ======== 
\newpage
\subsection{Wie wird das komplette System gemanagt?}
\label{subsec:completeSystem}
Für das Management des shared Memory wurde ein Struct erstellt (siehe Listing \ref{shmctrstruct}, welches das Shared Memory kontrollieren soll.

\lstset{language=c, mathescape=true}
\lstinputlisting[label=shmctrstruct,captionpos=b, caption=shm\_ctr\_struct]{dir/listings/shm_ctr_struct.txt}

Folgende Tabelle soll aufzeigen, welches Attribut im Struct welche Funktion übernehmen soll. Das Ziel des Structs ist eine verkette Liste. Das erste Struct ist im Main global bekannt, das letzte wird gefunden, da isLast auf TRUE gesetzt ist.
\begin{table}[h!]
\begin{tabular}[t]{|l|l|} \hline
 \cellcolor{darkgrey} &  \cellcolor{darkgrey}  \\ 
\cellcolor{darkgrey} \multirow{-2}{4.5cm}{\textbf{Struct Attribut}} &
\cellcolor{darkgrey} \multirow{-2}{8cm}{\textbf{Bezeichnung}}  \\  \cline{1-2}
int shm\_size & Grösse des Blockes des Shared Memory Bereiches \\ \cline{1-2}
int isLast &  TRUE wenn es der letzte Block ist, sonst FALSE\\ \cline{1-2}
int isfree & TRUE wenn Block frei ist, FALSE wenn Block besetzt ist\\ \cline{1-2}
\multirow{2}{5cm}{struct shm\_ctr\_struct *next} & Pointer auf den nächsten Block\\ 
& (zeigt auf sich selber, wenn es der letzte Block ist)\\ \cline{1-2}
\multirow{2}{5cm}{char *filename} & Pointer auf den Dateinamen, der im Block gespeichert ist\\ 
& (NULL wenn kein File gespeichert ist)\\ \cline{1-2}
\multirow{2}{5cm}{char *filedata}  &  Dies ist der einzige Pointer auf das Shared-Memory.\\
 &  Hier liegen die effektiven Daten des Files.\\ \cline{1-2}
\multirow{2}{5cm}{pthread\_rwlock\_t rwlockFile} &  Für jede Instanz des Structs und somit für jedes\\
&  unique File wird ein ReadWrite-Lock erstellt.\\ \cline{1-2}
\end{tabular}
\caption{Shared Memory control Struct}
\label{tab:shm_ctl_struct}
\end{table}


%============== N E W  ==== S U B - S E C T I O N  ======== 
\newpage
\subsection{Wie wird der optimale Block für ein neues File im Shared Memory gefunden?}

Hierzu wurde die Funktion find\_shm\_place(\dots) erstellt.\\
Diese Funktion beginnt beim ersten Eintrag des Structs shm\_ctr\_struct (siehe Listing \ref{shmctrstruct}) und sucht über alle vorhanden Blöcke (über den next-Pointer) einen optimalen Block. Optimal bedeutet, dass er grösser oder gleich der Grösse der neu zu erstellenden Dokumentes  sein muss, aber nicht grösser als das doppelte . Wäre er grösser als das Doppelte, wäre das Speicherplatzverschwendnung. Zusätzlich muss er frei sein (isfree = TRUE).



%============== N E W  ==== S U B - S E C T I O N  ======== 
\newpage
\subsection{Gibt es nur zu grosse Blöcke, wie werden die geteilt?}
Das Buddy-System gibt vor, dass die Blockgrössen aus 2er Potenzen gebildet werden. Also 2, 4, 8, 16, 32 \dots \\
Beispiel Buddy-System:\\
\begin{table}[h!]
\begin{tabularx}{\textwidth}{ |X|X|X|X| }
  \hline
 \multirow{2}{*}{Shared Memory -- SIZE = 65535} \\  
   \\ \hline
\end{tabularx}
\caption{Shared Memory - 1}
\label{tab:shm-1}
\end{table}

Ist die Dateigrösse = 14547, gibt es keinen optimalen Block. Der optimale Block wäre hier $2^{14} (=16384)$. Der kleiner Block $2^{13} (=8192)$ wäre hier zu klein.
Zuerst muss müssen nun die Blöcke aufgeteilt werden, so dass folgende Blöcke entstehen:


\begin{table}[h!]
\begin{tabularx}{1\textwidth}{ |c|c|c|c| }
 \hline
Block 1 & Block 2 & \multicolumn{2}{|c|}{Block 3} \\ 
SIZE = 16384 & SIZE = 16384 & \multicolumn{2}{|c|}{SIZE = 32768} \\ \hline
\end{tabularx}
\caption{Shared Memory - 2}
\label{tab:shm-2}
\end{table}


Für die Aufteilung wurde die Funktion devide(\dots) implementiert.\\
Diese beginnt beim ersten Block und arbeitet sich (über den next-Pointer) nach hinten. Beim ersten gefundenen freien Block, wird nun die Block-Size halbiert.
Es wird ein neuer Block erzeugt und die Verlinkungen (next, previous, Pointer auf Filename und Filedata sowie isFree und size) werden dem bestehenden und neuen Block gesetzt, so dass die Linked-List wieder komplett vorhanden ist.\\
Ist die Blockgrösse die gewünschte Grösse, findet ein return = TRUE statt. Ansonsten wird die Funktion selber rekursiv aufgerufen, bis die Blockgrösse genügend klein ist. Dann erfolgt der return = TRUE.
Ein Screenshot der Funktion devide() ist im Anhang \ref{fig:shm-2} zu finden. Ebenfalls im Anhang \ref{fig:shm-1} und \ref{fig:shm-3} ist das Shared Memory vor und nach dem Einfügen eines neuen Files zu sehen.



%============== N E W  ==== S U B - S E C T I O N  ======== 
\newpage
\section{Locks}
Wie im Kapitel \ref{sec:Das Projekt} erwähnt, ist ein global Lock nicht erlaubt.\\Für die Umsetzung des Locks wurde schlussendlich kein mutex gewählt, wie anfangs gedacht war. Das Problem beim mutex ist, dass ein lesender Client das ganze File ebenfalls sperrt für weitere Lesezugriffe. Dies soll jedoch nicht der Fall sein.\\Aus diesem Grund wurde wurde auf \flqq pthread\_rwlock\_t\frqq\ zurückgegriffen.Die Impelementation des Locks wurde gemäss Tabelle im Kapitel \ref{subsec:completeSystem} vorgenommen.\\Da das Kontroll-Strukt für das Shared-Memory bereits vorhanden war, konnte \flqq pthread\_rwlock\_t\frqq\ ohne Probleme eingefügt werden.\\Soll nun ein ein File gelockt werden, kann das elegant gelöst werden:
\begin{itemize}
\item Wenn das File gelesen werden möchte, muss zwingend die Adresse des enstprechenden Strukt bereits vorhanden sein = struct shm\_ctr\_struct *shm\_ctr\item Nun kann ein ReadLock über pthread\_rwlock\_rdlock(\&(shm\_ctr->rwlockFile)); gemacht werden.
\end{itemize}


%============== N E W  ==== S U B - S E C T I O N  ======== 
\newpage
\section{Files und deren Funktionen}Um die auf den ersten Blick nicht ganz klare Strukturen aufzeigen zu können, soll sich dieses Kapitel mit den einzelnen Files geschäftigen, die für den Server und den Client notwendig sind. Jede Funktion jedes Files soll kurz und bündig erläutert werden.

\begin{table}[h!]
\begin{tabular}{|p{\textwidth}|}
\hline
\multicolumn{1}{c}{\cellcolor{darkgrey} \textbf{myfunctions.c }}\\ 
\multicolumn{1}{c}{\cellcolor{darkgrey} beinhaltet eigene definierte Funktionen} \\ \hline
\textbf{getFixCharLen(char *mychar, int mylength)}\\
füllt einen CharPointer bis zur gewählten Länge auf. Wird benötigt für schöne Darstellung im LOG\\\textbf{void print\_all\_shm\_blocks(struct shm\_ctr\_struct *shm\_ctr)}\\Gibt auf der Konsole alle Blöcke des SHM aus. Wird zu DEBUG-Zwecken benötigt\\\textbf{char * get\_all\_shm\_blocks(struct shm\_ctr\_struct *shm\_ctr)}\\Gibt alle Blöcke des SHM als char Pointer zurück. Wird benötigt, um Client das SHM zu übermitteln\\\textbf{void print\_single\_shm\_blocks(struct shm\_ctr\_struct *shm\_ctr)}\\Gibt auf der Konsole einen Block des SHM aus. Wird zu DEBUG-Zwecken benötigt\\\textbf{char * getSingleString(char *msg, \dots)}\\Gibt einen Char Pointer als Return Wert. Diese Funktion erlaubt es, einen ?String? mit Argumenten (z.B. \%i, \%s) zu übergeben. Diese werden zur Laufzeit interpretiert und als neuen Char Pointer zurückgegeben\\ \hline
\end{tabular}
\captionof{table}{bar}
\caption{myfunctions.c}
\label{tab:myfunctions.c}
\end{table}

